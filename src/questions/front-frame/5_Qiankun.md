# Qiankun

## 当前主流的微前端方案大概有哪些？

#### 类型：`拓展`

#### 级别：`W4`、`W5`、`W6`

#### 解答（6 分）

- **1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。
- **1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。
- **1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。
- **1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。
- **1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。
- **1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生

## Qiankun 有哪些优点？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（4 分）

- **1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。
- **1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。
- **1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。
- **1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。

## Qiankun 如何实现子应用的加载？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加
载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。

## Qiankun 如何处理子应用之间的公共依赖？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（1 分）

- **1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配
置 props 等方式将主应用中的公共依赖传递给子应用使用。

## 简述 Qiankun 中子应用的生命周期函数及其作用

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（4 分）

- **1：** bootstrap：子应用初始化时调用，只会调用一次。通常用于子应用的全局初始化操作，如初始化状态管理库、加载全局样式等。
- **1：** mount：子应用挂载到主应用容器时调用。可以在这里进行 DOM 渲染、数据初始化等操作。
- **1：** unmount：子应用从主应用容器中卸载时调用。用于清理子应用的资源，如销毁事件监听器、清除定时器等。
- **1：** update：可选的生命周期函数，当主应用向子应用传递的 props 发生变化时调用。用于更新子应用的状态和 UI。

## 请简要介绍一下 Qiankun 及其主要应用场景

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Qiankun 是一个基于 single-spa 的微前端实现库，由蚂蚁金服开源。它提供了简单、强大的微前端解决方案，用于将多个独立的前端应用整合到一个大的应用中。其主要应用场景包括：

- **1：** 大型项目拆分：将复杂的大型前端项目拆分成多个小型、独立的子应用，每个子应用可以由不同的团队独立开发、测试和部署。
- **1：** 旧系统升级：在不影响现有业务的前提下，逐步对旧系统进行升级改造，将新功能以子应用的形式集成到旧系统中。
- **1：** 多技术栈融合：允许在同一个项目中使用不同的前端技术栈（如 Vue、React、Angular 等），充分发挥各技术栈的优势。

## Qiankun 中主应用和子应用是如何通信的？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- **1：** props 通信：主应用在加载子应用时，可以通过 props 向子应用传递数据。子应用可以在 mount 生命周期中接收这些数据。例如：

```js
// 主应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8081',
    container: '#subapp-viewport',
    props: {
      message: 'Hello from main app'
    }
  }
]);

// 子应用
export async function mount(props) {
  console.log(props.message); // 输出: Hello from main app
}
```

- **1：** 事件通信：可以使用自定义事件来实现主应用和子应用之间的通信。主应用和子应用都可以触发和监听事件。Qiankun 提供了 window.dispatchEvent 和 window.addEventListener 来实现事件的触发和监听。
- **1：** 全局状态管理：使用第三方状态管理库（如 Redux、MobX 等），将状态存储在全局，主应用和子应用都可以访问和修改这些状态。

## Qiankun 的核心原理是什么？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（1 分）

- **1：** Qiankun 核心基于 single-spa 的生命周期管理机制。它通过监听主应用的路由变化，根据配置的规则匹配到对应的子应用。然后动态加载子应用的资源（如 HTML、CSS、JS），并
在合适的生命周期钩子（如挂载、卸载等）中对这些资源进行处理，实现子应用的渲染和销毁，同时解决子应用之间的样式隔离、JS 沙箱等问题。

## Qiankun 如何实现样式隔离？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **1：** Shadow DOM：Qiankun 内部可以利用 Shadow DOM 的特性，将子应用的 DOM 结构和样式封装在一个独立的作用域中，使其样式不会影响到外部主应用和其他子应用。
- **1：** CSS 前缀：给子应用的所有 CSS 类名添加特定的前缀，避免类名冲突，从而实现样式隔离。

## 当子应用出现加载失败的情况，如何进行处理？

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（1 分）

- **1：** 可以通过 registerMicroApps 的 lifecycles 配置项中的 beforeLoad 和 afterLoad 钩子来处理加载失败的情况。在 afterLoad 钩子中，可以捕获加载过程中
抛出的错误，并在页面上显示友好的错误提示信息，示例代码如下：

```js
registerMicroApps([
  {
    name: 'sub - app1',
    entry: '//localhost:8081',
    container: '#sub - app - container',
    activeRule: '/sub - app1'
  }
], {
  afterLoad: (app) => {
    return new Promise((resolve, reject) => {
      try {
        // 子应用加载成功
        resolve();
      } catch (error) {
        // 显示错误提示
        console.error('子应用加载失败:', error);
        reject(error);
      }
    });
  }
});
```